import numpy as npfrom utils import *class KnSharing:    def __init__(self,image, k, n, recons):        self.k = k        self.n = n        self.image = image        self.N, self.D = image.size        self.recons = recons        self.encrypted_shares = np.zeros((n, self.N, self.D, 3))        self.decrypted_shares = np.zeros((n, self.N, self.D, 3))    def generate_random_var(self, n):        rand = np.array([])        count = 0        while count < self.recons:            random = randi(n)            if random not in rand:                rand = np.append(rand, random)                count = count + 1        return rand    def create_shares(self):        stego_image_bit_stream = to_24_bit_stream(self.image)        row_size = stego_image_bit_stream.shape[0]        column_size = stego_image_bit_stream.shape[1]        temp = np.zeros((self.n, row_size, column_size))        shares = np.zeros((self.n, self.N, self.D, 3))        print("K-N Secret Sharing progress is started : ")        for row in tqdm(range(row_size), desc="K-N Secret Sharing progress is started : "):            for column in range(column_size):                if stego_image_bit_stream[row, column] == 1:                    rand = self.generate_random_var(self.n)                    for share in range(self.recons):                        temp[int(rand[share]), row_size - 1 - row, column_size - 1 - column] = 1                    check = 0                    for control in range(self.n):                        check += int(temp[control, row_size - 1 - row, column_size - 1 - column])                    assert check == self.recons, "Error"        for idx in range(self.n):            rgb = temp[idx, :, :]            shares[idx, :, :, :] = np.array(bit_stream_of_24_to_image(rgb, self.N, self.D))            bit_stream_of_24_to_image(rgb, self.N, self.D).show()        self.encrypted_shares = shares        return shares    def decrypt_shares(self, shares):        #self.encrypted_shares = shares        temp = np.zeros((self.N * self.D, 24), dtype=np.uint8)        for share_idx in range(self.n):            share = (shares[share_idx])            #pil_image = Image.fromarray(share.astype('uint8'), 'RGB')            reconstructed_stego = to_24_bit_stream(share)            temp = (temp | np.flip(reconstructed_stego))        self.decrypted_shares = bit_stream_of_24_to_image(temp, self.N, self.D)        self.decrypted_shares.show()        return self.decrypted_shares